# EVMPatch

## Background

​	目前，修复错误并及时部署修补过的合约极具挑战性。由于**区块链系统的分布式特性，智能合约始终在线**，因此即时修补尤为重要。智能合约管理着大量资产，这些资产面临风险，并且在遭受攻击后往往无法恢复。EVMPATCH 为流行的以太坊区块链提供字节码重写引擎，并透明/自动地将常见的现成合约重写为可升级的合约。 EVMPATCH 的概念验证实现会自动强化易受整数上溢/下溢和访问控制错误影响的智能合约，可以轻松扩展以涵盖更多错误类别。

### Contribution

​	解决了自动及时修补智能合约的问题，助开发人员立即对报告的智能合约错误采取行动。

​	引入了一种新颖的修补框架，具有用于以太坊智能合约的字节码重写器，独立于源编程语言并且适用于未修改的合约代码。

​	框架会自动重放修补合约上的交易以：

1. 测试修补后的合约相对于与合约相关的先前交易的函数正确性，
2. 识别潜在的攻击，即开发人员可以确定他们的易受攻击的合约过去是否受到过攻击。





以太坊具有一种机制来限制每个智能合约的执行时间并奖励执行智能合约的矿工：所谓的gas。每条 EVM 指令都需要一定的 gas 预算才能执行。交易发送者选择以太币中每单位 gas 的价格，当交易被包含在区块中时，相应的以太币将作为奖励转移给矿工。



委托调用代理模式。在这里，一个智能合约被拆分为两个不同的合约，一个用于代码，一个用于数据存储：i）不可变代理合约，持有所有资金和所有内部状态，但不实现任何业务逻辑； ii) 一个逻辑合约，它是完全无状态的并实现了所有实际的业务逻辑，即这个合约包含管理合约动作的实际代码。

## Framework Design

​	由以下主要组件组成：（1）由自动分析工具和公开漏洞披露组成的漏洞检测引擎，（2）将补丁应用到合约的字节码重写器，（3）补丁测试机制验证先前交易的补丁，以及 (4) 合约部署组件上传合约的补丁版本。首先，漏洞检测引擎识别漏洞的位置和类型。然后将此信息传递给字节码重写器，后者根据先前定义的补丁模板对合约进行补丁。修补后的合约随后被转发到补丁测试器，后者将所有过去的交易重播到合约。也就是说，我们不仅修补合约，还允许开发人员检索在原始合约和修补合约之间表现出不同行为和结果的交易列表。这些交易可作为对原始合约的潜在攻击的指标。如果列表为空，我们的框架会立即在以太坊区块链上自动部署打补丁的合约。接下来，我们将更详细地描述我们设计的四个主要组件。

![Architecture](https://img-blog.csdnimg.cn/ab5339256817450ba0f34096d5af7cda.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5piv5rC45piv5LmL,size_20,color_FFFFFF,t_70,g_se,x_16)





重写器通常采用两种静态分析技术：**控制流图 (CFG) 恢复和后续数据流分析**。 后者对于确定哪些指令是代码中使用的任何地址常量的来源是必要的。 对于 EVM 字节码，有两类指令与此上下文相关：代码跳转和常量数据引用。



## EVMPatch Implementation

基于蹦床的重写方法只需要最少的代码分析并且适用于大多数用例。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c7f5e49456145f1b4107ff782013e1d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5piv5rC45piv5LmL,size_20,color_FFFFFF,t_70,g_se,x_16)







## 补充知识

### **EVM & Smart Contracts:** 

​	以太坊区块链系统的核心是一个自定义虚拟机，称为以太坊虚拟机 (EVM)，它执行以太坊智能合约。 EVM 由具有自定义指令格式的简单的基于堆栈的虚拟机组成。**每条指令**都表示为一个一**字节的操作码**。参数在数据堆栈上传递。唯一的例外是 push 指令，它用于将常量压入堆栈。这些常量直接编码到指令字节中。此外，EVM 遵循哈佛架构模型并**将代码和数据分离到不同的地址空间**。实际上，EVM 具有用于不同目的的**不同地址空间**：**代码地址空间**，其中包含智能合约的代码并被认为是不可变的，用于存储全局状态的**存储地址空间**，以及用于临时数据的**内存地址空间**。



### 矿工和节点

在以太坊中，术语“矿工”和“节点”经常被使用，但它们指的是不同的概念。以下是它们之间的主要区别：

1. **节点 (Node)**：
   - 一个节点是运行以太坊协议的任何计算机或服务器。它保持网络的完整性和共识。
   - 节点维护并验证区块链的完整副本。
   - 有几种不同类型的节点，如全节点（存储整个区块链的历史记录）和轻节点（只存储部分数据）。
   - 所有矿工都是节点，但并非所有节点都是矿工。
2. **矿工 (Miner)**：
   - 矿工是特殊类型的节点，它们参与共识过程，尤其是工作量证明 (Proof of Work, PoW)。
   - 矿工通过解决复杂的数学难题来竞争创建新的区块。成功的矿工会获得区块奖励和交易费用作为奖励。
   - 矿工不仅验证交易，还决定哪些交易包含在新的区块中。
   - 矿工的存在是为了确保以太坊网络的安全性和去中心化。

简而言之，**所有矿工都是节点，但并非所有节点都是矿工**。**节点主要负责验证和传播交易**，**而矿工则参与新区块的创建和竞争过程**。随着以太坊逐渐从PoW转向权益证明 (Proof of Stake, PoS)，矿工的角色和定义也将发生变化，因为PoS不再需要传统的“挖矿”过程。



### “基本块”（Basic Block）

是编译器优化和程序分析中的一个基本概念。一个基本块是一个没有跳转和分支的连续指令序列：也就是说，在执行过程中，如果基本块的第一条指令被执行，那么该块中的其它所有指令都将顺序执行，没有中断。

基本块有两个重要的性质：

1. 它只有一个入口：即只有第一条指令有可能被从块外部直接跳转到。
2. 它只有一个出口：即只有最后一条指令可能导致控制流离开该块。

在编译器的很多阶段，如优化、分析和代码生成等，经常需要以基本块为单位进行操作。这是因为基本块内的指令流是简单、连续且可预测的，这使得对其进行操作变得相对简单。

所以，当论文中提到“在基本块级别上工作”时，它指的是在这些没有分支的连续指令序列上进行操作。而当提到“将整个基本块复制到合约末尾”时，这意味着它们在某些情况下可能需要复制和移动这些没有分支的指令块。



### 控制流图 (CFG) 恢复和后续数据流分析

1. **控制流图 (Control Flow Graph, CFG)**:
   - 控制流图是一种用于表示程序所有运行时可能遵循的路径的图形表示。节点（或称为块）通常代表程序中的基本块，也就是连续执行的一段指令（如之前解释的那样，这段指令没有任何中间的跳转或分支）。边表示控制流的方向，即从一个基本块到另一个基本块的可能转移。
   - 进入和退出CFG的特殊节点分别称为“入口”和“出口”。
   - CFG允许我们理解程序如何在其执行期间流转，有助于编译器进行各种优化操作，如死代码消除、常量折叠等。
2. **数据流分析 (Data Flow Analysis)**:
   - 数据流分析是一个用于收集关于程序在其执行期间可能产生的信息的技术。它是编译器优化和很多静态分析工具的基础。
   - 数据流分析关心的是如何在程序的各个点上的变量信息，例如哪些变量可能是定义的、哪些变量可能是使用的、哪些变量可能是活跃的等。
   - 常见的数据流分析技术有：可用表达式分析、常量传播、寄存器活性分析、间接变量分析等。
   - 数据流分析通常在CFG上进行，因为CFG为分析提供了程序的结构框架，指明了信息如何流经程序的各个部分。

简单说，控制流图提供了程序的“地图”，显示了程序的结构，而数据流分析则在这个“地图”上分析如何传递和处理数据。这两个概念结合起来，为编译器提供了大量关于程序的信息，从而使其能够执行各种各样的优化和分析。



### 数字签名

数字签名的常见过程如下：

1. **生成哈希**：首先，对原始数据（可能是一条消息、文档等）进行哈希运算，产生一个固定大小的哈希值。这个哈希值可以视为原始数据的摘要。
2. **使用私钥加密**：然后，使用持有者的私钥对这个哈希值进行加密。加密后的哈希值就是所谓的“数字签名”。
3. **附加或发送签名**：这个数字签名随后可以附加到原始数据上或与之一起发送。接收者或第三方可以使用公钥进行验证。
4. **验证签名**：验证的过程通常如下：
   - 接收者使用相同的哈希函数对收到的原始数据生成哈希值。
   - 接收者同时使用发送者的公钥解密附加的数字签名，得到原始的哈希值。
   - 如果两个哈希值匹配，那么签名被视为有效，因为这意味着数据自签名生成以来没有被更改，且签名确实来自于私钥的持有者。

这种方法的优点是即使攻击者知道你是如何生成哈希的，他们也无法伪造签名，除非他们有私钥。而私钥不应该被泄露，因此这为数据的完整性和来源的真实性提供了保障。